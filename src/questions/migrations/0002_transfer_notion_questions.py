# Generated by Django 3.2.2 on 2021-10-28 15:05
from copy import copy
from typing import Dict, List

from django.db import migrations

from learney_web import settings
from notion_client import Client as NotionClient

CONCEPTS_NOTION_DB_ID = "e35066c7-0117-4c82-bb21-4ce579db798a"
LEARNEY_USER_ID = "Henry Pulver"
MIGRATION_SESSION_ID = "notion-migration-session-id"
BLOCK_CONTENTS_NAME = {"text": "content", "equation": "expression"}


def remove_starting_spaces(string_with_spaces: str) -> str:
    output = string_with_spaces
    # Remove unnecessary spaces at the start
    for count, character in enumerate(copy(string_with_spaces)):
        if character != " ":
            break
        else:
            output = string_with_spaces[count + 1 :]
    return output


def get_content(block_dict: Dict) -> str:
    block_type = block_dict["type"]
    if block_type == "text":
        return block_dict["text"]["content"]
    elif block_type == "equation":
        return f"$${block_dict['equation']['expression']}$$"
    else:
        raise TypeError(f"Notion block has unsuppored type ({block_type}): {block_dict}")


class Question:
    def __init__(self, question_page: Dict, concept_id: str):
        assert question_page["object"] == "page"
        self.question_id = (
            f'{concept_id}_{question_page["properties"]["ID"]["title"][0]["text"]["content"]}'
        )
        print(f"\nQuestion id: {self.question_id}")
        self.question_type = question_page["properties"]["Question type"]["select"]["name"]
        self.answer_type = question_page["properties"]["Answer type"]["select"]["name"]
        self.correct_answer = question_page["properties"]["Answer"]["rich_text"][0]["text"][
            "content"
        ]
        self.question_text = ""
        self.answers: List[str] = []
        self.feedback = ""

    def get_answer_list(self, answer_dict: Dict[str, str]):
        wrong_answers = [*answer_dict.values()]
        wrong_answers.remove(answer_dict[self.correct_answer])
        self.answers = [answer_dict[self.correct_answer]] + wrong_answers

    def get_text_from_question_blocks(self, question_block_list: List):
        answer_dict: Dict[str, str] = {}
        is_feedback = False
        for question_block in question_block_list:
            if question_block["type"] == "paragraph":
                is_feedback = is_feedback or says_feedback(question_block)
                is_answer_option = not is_feedback and is_answer(question_block)
                for index, block in enumerate(question_block["paragraph"]["text"]):
                    content = get_content(block)
                    if is_answer_option:
                        if index == 0:
                            answer_text = remove_starting_spaces(content)
                            answer_option = answer_text[0]
                            content = remove_starting_spaces(answer_text[2:])
                        answer_dict[answer_option] = answer_dict.get(answer_option, "") + content
                    elif not is_feedback:
                        self.question_text += content
                    # Below skips the word 'feedback'
                    elif content.lower() != "feedback":
                        self.feedback += content
                if is_feedback and self.feedback != "":  # Don't start feedback with a newline
                    self.feedback += "\n"
                elif not is_answer_option:
                    self.question_text += "\n"
            elif question_block["type"] == "equation":
                if is_feedback:
                    self.feedback += f"/$${question_block['equation']['expression']}$$/\n"
                else:
                    self.question_text += f"/$${question_block['equation']['expression']}$$/\n"

        print(f"question: {self.question_text}")
        print(f"Correct answer: {self.correct_answer}, answer_dict: {answer_dict}")
        self.get_answer_list(answer_dict)


def says_feedback(block_dict: Dict) -> bool:
    if len(block_dict["paragraph"]["text"]) <= 0:
        return False
    block_type = block_dict["paragraph"]["text"][0]["type"]
    return (
        block_dict["paragraph"]["text"][0][block_type][BLOCK_CONTENTS_NAME[block_type]].lower()
        == "feedback"
    )


def is_answer(block_dict: Dict) -> bool:
    if len(block_dict["paragraph"]["text"]) <= 0:
        return False
    lowercase_content = remove_starting_spaces(
        block_dict["paragraph"]["text"][0]["text"]["content"].lower()
    )
    if len(lowercase_content) < 2:
        return False
    return lowercase_content[0] in ["a", "b", "c", "d"] and lowercase_content[1] in [".", ")"]


def migrate_questions_from_notion(apps, schema_editor):
    QuestionModel = apps.get_model("questions", "QuestionModel")
    QuestionTagModel = apps.get_model("questions", "QuestionTagModel")
    KnowledgeMapModel = apps.get_model("knowledge_maps", "KnowledgeMapModel")
    notion_client = NotionClient(auth=settings.NOTION_KEY)
    orig_map = KnowledgeMapModel.objects.get(unique_id=settings.ORIG_MAP_UUID)
    for concept_id in settings.ORIG_MAP_CONCEPT_NAMES.keys():
        if not concept_id.isnumeric():
            continue
        # Get the questions that are possible choices
        notion_response = notion_client.databases.query(
            database_id=CONCEPTS_NOTION_DB_ID,
            filter={"property": "ID", "text": {"equals": concept_id}},
        )
        if len(notion_response["results"]) == 0:
            print(f"NO QUESTIONS for concept: {concept_id}")
            continue
        for topic_block in notion_client.blocks.children.list(
            block_id=notion_response["results"][0]["id"].replace("-", "")
        )["results"]:
            if (
                topic_block["type"] == "child_database"
            ):  # this block is the database of questions for this concept
                # Decide which questions to ask
                concept_question_page_list = notion_client.databases.query(
                    database_id=topic_block["id"]
                )["results"]
                for question_page in concept_question_page_list:
                    question = Question(
                        concept_id=concept_id,
                        question_page=question_page,
                    )
                    question.get_text_from_question_blocks(
                        notion_client.blocks.children.list(
                            block_id=question_page["id"].replace("-", "")
                        )["results"]
                    )
                    q_entry = QuestionModel.objects.create(
                        question_text=question.question_text,
                        answer_text=question.answers,
                        feedback_text=question.feedback,
                        author_user_id=LEARNEY_USER_ID,
                        session_id=MIGRATION_SESSION_ID,
                    )
                    print(
                        f"QuestionModel\nquestion_text={question.question_text},\n\
                        answer_text={question.answers},\n\
                        feedback_text={question.feedback}"
                    )
                    QuestionTagModel.objects.create(
                        question=q_entry,
                        map=orig_map,
                        concept_id=concept_id,
                    )
                    print(f"QuestionTagModel\nquestion={q_entry.id},\nconcept_id={concept_id}")


def reverse_add_notion_questions(apps, schema_editor):
    QuestionModel = apps.get_model("questions", "QuestionModel")
    for question_entry in QuestionModel.objects.filter(
        author_user_id=LEARNEY_USER_ID, session_id=MIGRATION_SESSION_ID
    ).prefetch_related("tags"):
        [tag.delete() for tag in question_entry.tags.all()]
        question_entry.delete()


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ("questions", "0001_initial"),
    ]

    operations = [
        migrations.RunPython(
            migrate_questions_from_notion, reverse_code=reverse_add_notion_questions
        ),
    ]
