# Generated by Django 3.2.2 on 2021-10-28 15:05
from copy import copy
from typing import Dict, List

from django.db import migrations

from learney_web import settings
from notion_client import Client as NotionClient

CONCEPTS_NOTION_DB_ID = "e35066c7-0117-4c82-bb21-4ce579db798a"
LEARNEY_USER_ID = "Henry Pulver"
MIGRATION_SESSION_ID = "notion-migration-session-id"
BLOCK_CONTENTS_NAME = {"text": "content", "equation": "expression"}


def remove_starting_spaces(string_with_spaces: str) -> str:
    output = string_with_spaces
    # Remove unnecessary spaces at the start
    for count, character in enumerate(copy(string_with_spaces)):
        if character != " ":
            break
        else:
            output = string_with_spaces[count + 1 :]
    return output


def get_content(block_dict: Dict) -> str:
    block_type = block_dict["type"]
    if block_type == "text":
        return block_dict["text"]["content"]
    elif block_type == "equation":
        return f"$${block_dict['equation']['expression']}$$"
    else:
        raise TypeError(f"Notion block has unsuppored type ({block_type}): {block_dict}")


class Question:
    def __init__(self, question_page: Dict, concept_id: str):
        assert question_page["object"] == "page"
        self.question_id = (
            f'{concept_id}_{question_page["properties"]["ID"]["title"][0]["text"]["content"]}'
        )
        print(f"\nQuestion id: {self.question_id}")
        self.question_type = question_page["properties"]["Question type"]["select"]["name"]
        self.answer_type = question_page["properties"]["Answer type"]["select"]["name"]
        self.correct_answer = question_page["properties"]["Answer"]["rich_text"][0]["text"][
            "content"
        ]
        self.question_text = ""
        self.answers: List[str] = []
        self.feedback = ""

    def get_answer_list(self, answer_dict: Dict[str, str]):
        wrong_answers = [*answer_dict.values()]
        wrong_answers.remove(answer_dict[self.correct_answer])
        self.answers = [answer_dict[self.correct_answer]] + wrong_answers

    def get_text_from_question_blocks(self, question_block_list: List):
        answer_dict = {}
        is_feedback = False
        for question_block in question_block_list:
            if question_block["type"] == "paragraph":
                is_feedback = says_feedback(question_block) or is_feedback
                is_answer_option = is_answer(question_block) and not is_feedback
                for block in question_block["paragraph"]["text"]:
                    content = get_content(block)
                    if is_answer_option:
                        answer_text = remove_starting_spaces(content)
                        answer_dict[answer_text[0]] = remove_starting_spaces(answer_text[2:])
                    elif not is_feedback:
                        self.question_text += content
                    # Below skips the word 'feedback'
                    elif content.lower() != "feedback":
                        self.feedback += content
                if is_feedback:
                    self.feedback += "\n"
                elif not is_answer_option:
                    self.question_text += "\n"
            elif question_block["type"] == "equation":
                if is_feedback:
                    self.feedback += f"/$${question_block['equation']['expression']}$$/\n"
                else:
                    self.question_text += f"/$${question_block['equation']['expression']}$$/\n"

        print(f"question: {self.question_text}")
        print(f"Correct answer: {self.correct_answer}, answer_dict: {answer_dict}")
        self.get_answer_list(answer_dict)


def says_feedback(block_dict: Dict) -> bool:
    if len(block_dict["paragraph"]["text"]) > 0:
        return block_dict["paragraph"]["text"][0]["text"]["content"].lower() == "feedback"
    else:
        return False


def is_answer(block_dict: Dict) -> bool:
    if len(block_dict["paragraph"]["text"]) > 0:
        lowercase_content = remove_starting_spaces(
            block_dict["paragraph"]["text"][0]["text"]["content"].lower()
        )
        if len(lowercase_content) < 2:
            return False
        return lowercase_content[0] in ["a", "b", "c", "d"] and lowercase_content[1] in [".", ")"]
    else:
        return False


def migrate_questions_from_notion(apps, schema_editor):
    QuestionModel = apps.get_model("questions", "QuestionModel")
    QuestionConceptTagModel = apps.get_model("questions", "QuestionConceptTagModel")
    notion_client = NotionClient(auth=settings.NOTION_KEY)
    for concept_id in settings.ORIG_MAP_CONCEPT_NAMES.keys():
        if not concept_id.isnumeric():
            continue
        # Get the questions that are possible choices
        notion_response = notion_client.databases.query(
            database_id=CONCEPTS_NOTION_DB_ID,
            filter={"property": "ID", "text": {"equals": concept_id}},
        )
        if len(notion_response["results"]) == 0:
            print(f"NO QUESTIONS for concept: {concept_id}")
            continue
        for topic_block in notion_client.blocks.children.list(
            block_id=notion_response["results"][0]["id"].replace("-", "")
        )["results"]:
            if (
                topic_block["type"] == "child_database"
            ):  # this block is the database of questions for this concept
                # Decide which questions to ask
                concept_question_page_list = notion_client.databases.query(
                    database_id=topic_block["id"]
                )["results"]
                for question_page in concept_question_page_list:
                    question = Question(
                        concept_id=concept_id,
                        question_page=question_page,
                    )
                    question.get_text_from_question_blocks(
                        notion_client.blocks.children.list(
                            block_id=question_page["id"].replace("-", "")
                        )["results"]
                    )
                    q_entry = QuestionModel.objects.create(
                        question_text=question.question_text,
                        answer_text=question.answers,
                        feedback_text=question.feedback,
                        author_user_id=LEARNEY_USER_ID,
                        session_id=MIGRATION_SESSION_ID,
                    )
                    print(
                        f"QuestionModel\nquestion_text={question.question_text},\n\
                        answer_text={question.answers},\n\
                        feedback_text={question.feedback}"
                    )
                    QuestionConceptTagModel.objects.create(
                        question_id=q_entry.id,
                        map_uuid=settings.ORIG_MAP_UUID,
                        concept_id=concept_id,
                    )
                    print(
                        f"QuestionConceptTagModel\nquestion_id={q_entry.id},\nconcept_id={concept_id}"
                    )


def reverse_add_notion_questions(apps, schema_editor):
    QuestionModel = apps.get_model("questions", "QuestionModel")
    QuestionConceptTagModel = apps.get_model("questions", "QuestionConceptTagModel")
    for question_entry in QuestionModel.objects.filter(
        author_user_id=LEARNEY_USER_ID, session_id=MIGRATION_SESSION_ID
    ):
        for question_tag_entry in QuestionConceptTagModel.objects.filter(
            question_id=question_entry.id
        ):
            question_tag_entry.delete()
        question_entry.delete()


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ("questions", "0001_initial"),
    ]

    operations = [
        migrations.RunPython(
            migrate_questions_from_notion, reverse_code=reverse_add_notion_questions
        ),
    ]
